# Проектная работа "Веб-ларек"

## Назначение
Веб-приложение для демонстрации каталога товаров, добавления их в корзину и оформления заказа. Архитектура приложения реализована в стиле **Model-View-Presenter (MVP)** с модульной организацией кода. Основное внимание уделено разделению ответственности, расширяемости и повторному использованию компонентов.

---

## Стек технологий
HTML, SCSS, TS, Webpack

---

## Структура проекта
- `src/` — исходный код приложения;
  - `components/` — визуальные и логические компоненты;
  - `api/` — взаимодействие с сервером;
  - `common.blocks/` — SCSS-стили для компонентов интерфейса;
  - `index.ts` — точка входа и инициализация приложения.

---

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```


## Архитектура
Архитектура реализована по шаблону **MVP**:
- **Model** — отвечает за данные, логику и бизнес-состояние (например, корзина);
- **View** — визуальные компоненты, получающие данные через presenter;
- **Presenter** — координация: получает действия от view, обрабатывает их, обновляет model и view.

---

## Компоненты и классы

### `CartStore.ts` — модель корзины
Класс `CartStore` реализует хранение и управление товарами в корзине. Использует шаблон наблюдатель:
- **Методы:**
  - `addProduct(id: string)` — добавление товара;
  - `removeProduct(id: string)` — удаление;
  - `getItems()` — получить список всех товаров;
  - `getTotalPrice()` — рассчитать сумму заказа;
  - `subscribe(callback: Function)` — подписка на изменение состояния;
  - `notify()` — вызвать обновление у подписчиков.
- **Задача:** поддерживать актуальное состояние корзины и предоставлять API для работы с ней.

### `getProducts.ts` — получение списка товаров
- Выполняет HTTP GET-запрос на API.
- Возвращает `Promise<Product[]>` — данные для генерации карточек.
- Используется при инициализации приложения.

### `submitOrder.ts` — отправка заказа
- Принимает объект заказа (`Order`).
- Отправляет POST-запрос на сервер.
- Возвращает результат — объект `OrderResult` с информацией о заказе.

### `index.ts` — координатор приложения (Presenter)
- Получает список товаров и инициализирует отображение карточек;
- Обрабатывает события от карточек (добавление в корзину);
- Реагирует на действия пользователя: оформление заказа, открытие корзины, очистка;
- Связывает компоненты с `CartStore`.

---

## Структура пользовательского интерфейса (View)
Весь UI стилизуется через SCSS (папка `common.blocks`). Компоненты не содержат логики — они реагируют на данные и действия:

- **card.scss** — карточка товара;
- **gallery.scss** — галерея карточек;
- **form.scss** — оформление формы заказа;
- **basket.scss** — список корзины;
- **modal.scss** — модальное окно для подтверждения и ошибок;
- **header.scss** — отображение счётчика и кнопки корзины;

---

## Типы данных

```ts
interface Product {
  id: string;
  title: string;
  price: number;
  description: string;
  category: string;
  image: string;
}

interface Order {
  items: string[];
  address: string;
  email: string;
  phone: string;
}

interface OrderResult {
  id: string;
  total: number;
}
```

---

## Сценарии работы

### Добавление товара
- Пользователь нажимает кнопку «Купить» в карточке.
- Presenter вызывает `cartStore.addProduct(id)`.
- Модель обновляет состояние, вызывает `notify()`.
- UI-компоненты подписаны на изменения и перерисовываются.

### Оформление заказа
- Пользователь заполняет форму и отправляет.
- Presenter формирует объект `Order` и вызывает `submitOrder`.
- После ответа сервера отображается результат (`Modal`).

---

## Принципы разработки

### Изолированность
- Каждый модуль работает независимо (CartStore не зависит от UI);
- API взаимодействует с сервером отдельно от бизнес-логики.

### SRP (единственная ответственность)
- `CartStore` — только логика корзины;
- `submitOrder` — только отправка заказа;
- `index.ts` — связующее звено.

### Масштабируемость
- Новый функционал (например, избранное) можно внедрить без изменения существующих модулей;
- UI можно заменить без переписывания логики;
- Возможность повторного использования компонентов (например, `Modal`).

## Роль сеттеров и геттеров

Сеттеры и геттеры используются в компонентах View и Model для управления внутренними данными и визуальным отображением.

### Сеттеры (`set`)

Сеттеры применяются для передачи данных от Presenter или Model во View-компоненты. Они обновляют визуальные свойства интерфейса:

- `set title(value: string)` — обновляет название товара в карточке.
- `set price(value: number)` — отображает цену товара.
- `set image(src: string)` — подставляет изображение в карточку товара.
- `set description(value: string)` — выводит описание товара.
- `set content(value: HTMLElement)` — задаёт содержимое модального окна.
- `set total(value: number | string)` — отображает сумму товаров в корзине.
- `set items(value: HTMLElement[])` — обновляет список товаров в корзине.
- `set address(value: string)` — передаёт адрес доставки в форму заказа.
- `set payment(value: string)` — устанавливает выбранный способ оплаты.

### Геттеры (`get`)

Геттеры используются для доступа к данным компонента, не взаимодействуя напрямую с DOM:

- `get id()` — возвращает идентификатор карточки товара.
- `get index()` — возвращает индекс товара (если используется).
- `get title()` — получает текущее название товара в карточке.
- `get price()` — получает установленную цену товара.

Геттеры и сеттеры обеспечивают строгую инкапсуляцию и позволяют работать с данными безопасно и декларативно. Благодаря этому компоненты остаются универсальными, независимыми и легко тестируемыми.